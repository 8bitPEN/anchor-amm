/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from "@solana/kit";
import {
  type ParsedDepositInstruction,
  type ParsedInitializePoolInstruction,
  type ParsedSkimInstruction,
  type ParsedSwapInstruction,
  type ParsedSyncInstruction,
  type ParsedWithdrawInstruction,
} from "../instructions";

export const ANCHOR_AMM_PROGRAM_ADDRESS =
  "2sU17QtTHDBCr4Q3pZGVUjE71fFyfjiuAjVGqRP91Be5" as Address<"2sU17QtTHDBCr4Q3pZGVUjE71fFyfjiuAjVGqRP91Be5">;

export enum AnchorAmmAccount {
  LiquidityPool,
}

export function identifyAnchorAmmAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): AnchorAmmAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([1])),
      0,
    )
  ) {
    return AnchorAmmAccount.LiquidityPool;
  }
  throw new Error(
    "The provided account could not be identified as a anchorAmm account.",
  );
}

export enum AnchorAmmInstruction {
  Deposit,
  InitializePool,
  Skim,
  Swap,
  Sync,
  Withdraw,
}

export function identifyAnchorAmmInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): AnchorAmmInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([2])),
      0,
    )
  ) {
    return AnchorAmmInstruction.Deposit;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([1])),
      0,
    )
  ) {
    return AnchorAmmInstruction.InitializePool;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([6])),
      0,
    )
  ) {
    return AnchorAmmInstruction.Skim;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([3])),
      0,
    )
  ) {
    return AnchorAmmInstruction.Swap;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([5])),
      0,
    )
  ) {
    return AnchorAmmInstruction.Sync;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([4])),
      0,
    )
  ) {
    return AnchorAmmInstruction.Withdraw;
  }
  throw new Error(
    "The provided instruction could not be identified as a anchorAmm instruction.",
  );
}

export type ParsedAnchorAmmInstruction<
  TProgram extends string = "2sU17QtTHDBCr4Q3pZGVUjE71fFyfjiuAjVGqRP91Be5",
> =
  | ({
      instructionType: AnchorAmmInstruction.Deposit;
    } & ParsedDepositInstruction<TProgram>)
  | ({
      instructionType: AnchorAmmInstruction.InitializePool;
    } & ParsedInitializePoolInstruction<TProgram>)
  | ({
      instructionType: AnchorAmmInstruction.Skim;
    } & ParsedSkimInstruction<TProgram>)
  | ({
      instructionType: AnchorAmmInstruction.Swap;
    } & ParsedSwapInstruction<TProgram>)
  | ({
      instructionType: AnchorAmmInstruction.Sync;
    } & ParsedSyncInstruction<TProgram>)
  | ({
      instructionType: AnchorAmmInstruction.Withdraw;
    } & ParsedWithdrawInstruction<TProgram>);
